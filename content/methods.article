Методы и итерфейсы
Этот урок охватывает методы и интерфейсы - конструкции, которые определяют объекты и их поведение.

#en: Methods and interfaces
#en: This lesson covers methods and interfaces, the constructs that define objects and their behavior.

The Go Authors
https://golang.org

* Методы
#en: * Methods

В Go нет классов.
Впрочем, вы можете определять методы на типах.
#en: Go does not have classes.
#en: However, you can define methods on types.

Метод - это функция со специальным аргументом _приемником_.
#en: A method is a function with a special _receiver_ argument.

Приемник отображается в своем собственном списке аргументов между ключевым словом
`func` и именем метода.
#en: The receiver appears in its own argument list between the `func` keyword and
#en: the method name.

В этом примере метод `Abs` имеет приемник типа` Vertex` с именем `v`.
#en: In this example, the `Abs` method has a receiver of type `Vertex` named `v`.

.play methods/methods.go

* Методы и функции
#en: * Methods are functions

Запомните: метод - это всего лишь функция с аргументом-приемником.
#en: Remember: a method is just a function with a receiver argument.

Вот функция `Abs`, написанная в виде обычной функции без изменения функциональности.
#en: Here's `Abs` written as a regular function with no change in functionality.

.play methods/methods-funcs.go

* Методы. Продолжение.
#en: * Methods continued

Вы также можете объявить метод на любом своем типе, а не только на структурах.
#en: You can declare a method on non-struct types, too.

В этом примере мы видим числовой тип `MyFloat` с методом `Abs`.
#en: In this example we see a numeric type `MyFloat` with an `Abs` method.

Вы можете объявлять метод только с тем приемником, который определен в том же пакете,
что и метод.
Вы не можете объявить метод с приемником, который определен в другом пакете (что
включает в себя встроенные типы, такие как `int`).
#en: You can only declare a method with a receiver whose type is defined in the same
#en: package as the method.
#en: You cannot declare a method with a receiver whose type is defined in another
#en: package (which includes the built-in types such as `int`).

.play methods/methods-continued.go

Методы с указателем в роли приемника
#en: * Pointer receivers

Вы можете объявить метод с приемником, переданным по указателю.
#en: You can declare methods with pointer receivers.

Это значит, что тип приемника имеет синтаксис литерала `*T` для некоторого типа `T`.
(Кроме того, `T` не может указывать на самого себя, как в случае с `*int`.)
#en: This means the receiver type has the literal syntax `*T` for some type `T`.
#en: (Also, `T` cannot itself be a pointer such as `*int`.)

Например, метод `Scale` объявлен на `*Vertex`.
#en: For example, the `Scale` method here is defined on `*Vertex`.

Методы с приемником по указателю могут изменять значение, на которое указывает
приемник (как здесь делает `Scale`).
Поскольку часто необходимо в методах изменять приемник, передача приемника по указателю
используются чаще, чем передача приемника по значению.
#en: Methods with pointer receivers can modify the value to which the receiver
#en: points (as `Scale` does here).
#en: Since methods often need to modify their receiver, pointer receivers are more
#en: common than value receivers.

Попробуйте удалить символ `*` из объявления функции `Scale` на строке 16 и посмотрите,
как изменится поведение программы.
#en: Try removing the `*` from the declaration of the `Scale` function on line 16
#en: and observe how the program's behavior changes.

С передачей приемника по значению, метод `Scale` работает с копией оригинального
значения `Vertex`.
(Это точно такое же поведение, как и для любого другого аргумента функции.)
Методу `Scale` необходимо передать приемник по указателю, чтобы изменить значение `Vertex`,
объявленное в функции `main`.
#en: With a value receiver, the `Scale` method operates on a copy of the original
#en: `Vertex` value.
#en: (This is the same behavior as for any other function argument.)
#en: The `Scale` method must have a pointer receiver to change the `Vertex` value
#en: declared in the `main` function.

.play methods/methods-pointers.go

* Указатели и функции
#en: * Pointers and functions

Здесь мы видим методы `Abs` и `Scale`, переписанные в виде функций.
#en: Here we see the `Abs` and `Scale` methods rewritten as functions.

Попробуйте снова удалить `*` со строки 16.
Можетели вы понять, почему поведение изменилось?
Что еще вам нужно изменить, чтобы пример скомпилировался?
#en: Again, try removing the `*` from line 16.
#en: Can you see why the behavior changes?
#en: What else did you need to change for the example to compile?

(Если вы не уверены, пройдите на следующую страницу.)
#en: (If you're not sure, continue to the next page.)

.play methods/methods-pointers-explained.go

* Методы и косвеность указателей
#TODO: Не уверен, что верный перевод
#en: * Methods and pointer indirection

Сравнивая две предыдущие программы, вы могли заметить, что функции
с аргументами по указателю должны принимать указатели:
#en: Comparing the previous two programs, you might notice that
#en: functions with a pointer argument must take a pointer:

	var v Vertex
	ScaleFunc(v)  // Ошибка компиляции
	ScaleFunc(&v) // OK

в то время как методы с приемниками по указателю могут быть вызваны как на
указателе, так и на значении: // TODO: не нравится!
#en: while methods with pointer receivers take either a value or a pointer as the
#en: receiver when they are called:

	var v Vertex
	v.Scale(5)  // OK
	p := &v
	p.Scale(10) // OK

Для оператора `v.Scale(5)`, даже если `v` это значение, а не указатель,
метод с приемником по указателю, вызовется автоматичестки.
То есть, для удобства, Go интерпретирует оператор `v.Scale(5)` как `(&v).Scale(5)`,
поскольку метод `Scale` принимает приемник по указателю.
#en: For the statement `v.Scale(5)`, even though `v` is a value and not a pointer,
#en: the method with the pointer receiver is called automatically.
#en: That is, as a convenience, Go interprets the statement `v.Scale(5)` as
#en: `(&v).Scale(5)` since the `Scale` method has a pointer receiver.

.play methods/indirection.go

* Методы и косвеность указателей (2)
#TODO: Не уверен, что верный перевод
#en: * Methods and pointer indirection (2)

Подобные вещи происходят и в обратном направлении.
#en: The equivalent thing happens in the reverse direction.

Функции, которые принимают аргумент по значению должны получать значение этого конкретного типа:
#en: Functions that take a value argument must take a value of that specific type:

	var v Vertex
	fmt.Println(AbsFunc(v))  // OK
	fmt.Println(AbsFunc(&v)) // Ошибка компиляции!

в то время, как методы с приемником по значению могут принимать как значение, так и указатель
во время вызова:
#en: while methods with value receivers take either a value or a pointer as the
#en: receiver when they are called:

	var v Vertex
	fmt.Println(v.Abs()) // OK
	p := &v
	fmt.Println(p.Abs()) // OK

В этом случае вызов метода `p.Abs()` интерпретируется как `(*p).Abs()`.
#en: In this case, the method call `p.Abs()` is interpreted as `(*p).Abs()`.

.play methods/indirection-values.go

*Выбор передачи приемника по значению или указателю
#en: * Choosing a value or pointer receiver

Есть две причины, чтобы использовать приемник по указателю.
#en: There are two reasons to use a pointer receiver.

Во-первых, чтобы в методе можно было изменять значение, на которое указывает приемник.
#en: The first is so that the method can modify the value that its receiver points to.

Во-вторых, чтобы избежать копирования значения при каждом вызове метода.
Например, это может быть эффективным, если получатеть является большой структурой.
#en: The second is to avoid copying the value on each method call.
#en: This can be more efficient if the receiver is a large struct, for example.

В этом примере оба метода (и `Scale`, и `Abs) принимают тип `*Vertex`, даже несмотря на то,
что в методе `Abs` не нужно менять приемник.
#en: In this example, both `Scale` and `Abs` are with receiver type `*Vertex`,
#en: even though the `Abs` method needn't modify its receiver.

В общем, все методы на данном типе должны иметь приемник либо по значению, либо по указателю,
но не смесь и того, и другого.
(Мы увидим почему на следущих страницах.)
#en: In general, all methods on a given type should have either value or pointer
#en: receivers, but not a mixture of both.
#en: (We'll see why over the next few pages.)

.play methods/methods-with-pointer-receivers.go

* Интерфейсы
#en: * Interfaces

_Тип_интерфейса_ определяет множество сигнатур методов.
#en: An _interface_type_ is defined as a set of method signatures.

Значением типа интерфейса может быть любое значение, которое реализует его методы.
#en: A value of interface type can hold any value that implements those methods.

*Примечание:* Злесь допущена ошибка в коде примера на строке 22.
`Vertex` (тип значения) не реализует интерфейс `Abser`, потому что
метод `Abs` определен только на `*Vertex` (тип указателя).
#TODO: (the pointer type) - сомневаюсь.
#en: *Note:* There is an error in the example code on line 22.
#en: `Vertex` (the value type) doesn't implement `Abser` because
#en: the `Abs` method is defined only on `*Vertex` (the pointer type).

.play methods/interfaces.go

Интерфейсы реализуются неявно
#en: * Interfaces are implemented implicitly

Тип реализует интерфейс реализуя его методы.
В Go нет явного заверения о намерении, нет ключевого слова "implements".
#TODO: может совсем не переводить explicit declaration of intent
#en: A type implements an interface by implementing its methods.
#en: There is no explicit declaration of intent, no "implements" keyword.

Неявные интерфейсы разделяют определение интерфеса от его реализации,
которая может появится в любом пакете без предварительной договоренности.
#TODO: предварительной договоренности?
#en: Implicit interfaces decouple the definition of an interface from its
#en: implementation, which could then appear in any package without prearrangement.

.play methods/interfaces-are-satisfied-implicitly.go

* Значения интерфейса
#en: * Interface values

Под капотом, интерфейс можно рассматривать как кортеж из значения и конкретного типа:
#en: Under the covers, interface values can be thought of as a tuple of a value and a
#en: concrete type:

	(value, type)

Значение интерфейса имеет значение конкретного типа.
#TODO: не уверен в переводе
#en: An interface value holds a value of a specific underlying concrete type.

Вызов метода интерфеса выполняет метод с таким же названием конкретного типа.
#TODO: не уверен в переводе
#en: Calling a method on an interface value executes the method of the same name on
#en: its underlying type.

.play methods/interface-values.go

Интерфейсы с нулевым значением
#TODO: стоит ли переводить nil?
#en: * Interface values with nil underlying values

Если конкретное значение внутри интерфейса равно nil, метод будет вызван
с примеником, равным nil.
#en: If the concrete value inside the interface itself is nil,
#en: the method will be called with a nil receiver.

В некоторых языках данная ситуация приведет к null pointer exception,
но в Go это обычная ситуация писать методы, которые корректно обрабатывают
вызов с nil-приемником (как метод `M` в примере.)
#en: In some languages this would trigger a null pointer exception,
#en: but in Go it is common to write methods that gracefully handle being called
#en: with a nil receiver (as with the method `M` in this example.)

Стоит отметить, что значение интерфейса, имеющего нулевое конкретное значение,
само ненулевое.
#en: Note that an interface value that holds a nil concrete value is itself non-nil.

.play methods/interface-values-with-nil.go

Нулевое значение интерфейса
#en: * Nil interface values

Нулевое значение интерфейса не имеет ни значения, ни конкретного типа.
#en: A nil interface value holds neither value nor concrete type.

Вызов метода на нулевом интерфейсе приведет к ошибке выполнения, поскольку
нет никакого типа внутри интерфейса, позволяющего определить, какой
_конкретный_метод_ нужно вызвать.
#en: Calling a method on a nil interface is a run-time error because there is no
#en: type inside the interface tuple to indicate which _concrete_ method to call.

.play methods/nil-interface-values.go

Пустой интерфейс
#en: * The empty interface

Интерфейс, определяющий пустое множество методов, называется _пустым_интерфейсом_:
#en: The interface type that specifies zero methods is known as the _empty_interface_:

	interface{}

Пустой интерфейс может иметь значение любого типа.
(Каждый тип реализует как минимум ноль методов.)
#en: An empty interface may hold values of any type.
#en: (Every type implements at least zero methods.)

Пустой интерфейс используется в коде, который обрабатывает значения неизвестного типа.
Например, метод `fmt.Print` принимает любое количество аргументов типа `interface{}`.
#en: Empty interfaces are used by code that handles values of unknown type.
#en: For example, `fmt.Print` takes any number of arguments of type `interface{}`.

.play methods/empty-interface.go

#en: * Type assertions

#en: A _type_assertion_ provides access to an interface value's underlying concrete value.

	t := i.(T)

#en: This statement asserts that the interface value `i` holds the concrete type `T`
#en: and assigns the underlying `T` value to the variable `t`.

#en: If `i` does not hold a `T`, the statement will trigger a panic.

#en: To _test_ whether an interface value holds a specific type,
#en: a type assertion can return two values: the underlying value
#en: and a boolean value that reports whether the assertion succeeded.

	t, ok := i.(T)

#en: If `i` holds a `T`, then `t` will be the underlying value and `ok` will be true.

#en: If not, `ok` will be false and `t` will be the zero value of type `T`,
#en: and no panic occurs.

#en: Note the similarity between this syntax and that of reading from a map.

.play methods/type-assertions.go

#en: * Type switches

#en: A _type_switch_ is a construct that permits several type assertions in series.

#en: A type switch is like a regular switch statement, but the cases in a type
#en: switch specify types (not values), and those values are compared against
#en: the type of the value held by the given interface value.

	switch v := i.(type) {
	case T:
		// here v has type T
	case S:
		// here v has type S
	default:
		// no match; here v has the same type as i
	}

#en: The declaration in a type switch has the same syntax as a type assertion `i.(T)`,
#en: but the specific type `T` is replaced with the keyword `type`.

#en: This switch statement tests whether the interface value `i`
#en: holds a value of type `T` or `S`.
#en: In each of the `T` and `S` cases, the variable `v` will be of type
#en: `T` or `S` respectively and hold the value held by `i`.
#en: In the default case (where there is no match), the variable `v` is
#en: of the same interface type and value as `i`.

.play methods/type-switches.go

#en: * Stringers

#en: One of the most ubiquitous interfaces is [[//golang.org/pkg/fmt/#Stringer][`Stringer`]] defined by the [[//golang.org/pkg/fmt/][`fmt`]] package.

	type Stringer interface {
		String() string
	}

#en: A `Stringer` is a type that can describe itself as a string. The `fmt` package
#en: (and many others) look for this interface to print values.

.play methods/stringer.go

#en: * Exercise: Stringers

#en: Make the `IPAddr` type implement `fmt.Stringer` to print the address as
#en: a dotted quad.

#en: For instance, `IPAddr{1,`2,`3,`4}` should print as `"1.2.3.4"`.

.play methods/exercise-stringer.go

#en: * Errors

#en: Go programs express error state with `error` values.

#en: The `error` type is a built-in interface similar to `fmt.Stringer`:

	type error interface {
		Error() string
	}

#en: (As with `fmt.Stringer`, the `fmt` package looks for the `error` interface when
#en: printing values.)

#en: Functions often return an `error` value, and calling code should handle errors
#en: by testing whether the error equals `nil`.

	i, err := strconv.Atoi("42")
	if err != nil {
		fmt.Printf("couldn't convert number: %v\n", err)
		return
	}
	fmt.Println("Converted integer:", i)

#en: A nil `error` denotes success; a non-nil `error` denotes failure.

.play methods/errors.go

#en: * Exercise: Errors

#en: Copy your `Sqrt` function from the [[/flowcontrol/8][earlier exercise]] and modify it to return an `error` value.

#en: `Sqrt` should return a non-nil error value when given a negative number, as it doesn't support complex numbers.

#en: Create a new type

	type ErrNegativeSqrt float64

#en: and make it an `error` by giving it a

	func (e ErrNegativeSqrt) Error() string

#en: method such that `ErrNegativeSqrt(-2).Error()` returns `"cannot`Sqrt`negative`number:`-2"`.

#en: *Note:* a call to `fmt.Sprint(e)` inside the `Error` method will send the program into an infinite loop. You can avoid this by converting `e` first: `fmt.Sprint(float64(e))`. Why?

#en: Change your `Sqrt` function to return an `ErrNegativeSqrt` value when given a negative number.

.play methods/exercise-errors.go

#en: * Readers

#en: The `io` package specifies the `io.Reader` interface,
#en: which represents the read end of a stream of data.

#en: The Go standard library contains [[https://golang.org/search?q=Read#Global][many implementations]] of these interfaces, including files, network connections, compressors, ciphers, and others.

#en: The `io.Reader` interface has a `Read` method:

	func (T) Read(b []byte) (n int, err error)

#en: `Read` populates the given byte slice with data and returns the number of bytes
#en: populated and an error value. It returns an `io.EOF` error when the stream
#en: ends.

#en: The example code creates a
#en: [[//golang.org/pkg/strings/#Reader][`strings.Reader`]]
#en: and consumes its output 8 bytes at a time.

.play methods/reader.go

#en: * Exercise: Readers

#en: Implement a `Reader` type that emits an infinite stream of the ASCII character
#en: `'A'`.

.play methods/exercise-reader.go

#en: * Exercise: rot13Reader

#en: A common pattern is an [[https://golang.org/pkg/io/#Reader][io.Reader]] that wraps another `io.Reader`, modifying the stream in some way.

#en: For example, the [[https://golang.org/pkg/compress/gzip/#NewReader][gzip.NewReader]] function takes an `io.Reader` (a stream of compressed data) and returns a `*gzip.Reader` that also implements `io.Reader` (a stream of the decompressed data).

#en: Implement a `rot13Reader` that implements `io.Reader` and reads from an `io.Reader`, modifying the stream by applying the [[https://en.wikipedia.org/wiki/ROT13][rot13]] substitution cipher to all alphabetical characters.

#en: The `rot13Reader` type is provided for you.
#en: Make it an `io.Reader` by implementing its `Read` method.

.play methods/exercise-rot-reader.go

#en: * Images

#en: [[https://golang.org/pkg/image/#Image][Package image]] defines the `Image` interface:

	package image

	type Image interface {
		ColorModel() color.Model
		Bounds() Rectangle
		At(x, y int) color.Color
	}

#en: *Note*: the `Rectangle` return value of the `Bounds` method is actually an
#en: [[https://golang.org/pkg/image/#Rectangle][`image.Rectangle`]], as the
#en: declaration is inside package `image`.

#en: (See [[https://golang.org/pkg/image/#Image][the documentation]] for all the details.)

#en: The `color.Color` and `color.Model` types are also interfaces, but we'll ignore that by using the predefined implementations `color.RGBA` and `color.RGBAModel`. These interfaces and types are specified by the [[https://golang.org/pkg/image/color/][image/color package]]

.play methods/images.go

#en: * Exercise: Images

#en: Remember the picture generator you wrote earlier? Let's write another one, but this time it will return an implementation of `image.Image` instead of a slice of data.

#en: Define your own `Image` type, implement [[https://golang.org/pkg/image/#Image][the necessary methods]], and call `pic.ShowImage`.

#en: `Bounds` should return a `image.Rectangle`, like `image.Rect(0,`0,`w,`h)`.

#en: `ColorModel` should return `color.RGBAModel`.

#en: `At` should return a color; the value `v` in the last picture generator corresponds to `color.RGBA{v,`v,`255,`255}` in this one.

.play methods/exercise-images.go

* Поздравляем!
#en: * Congratulations!

Вы завершили этот урок!
#en: You finished this lesson!

Вы можете перейти назад к списку уроков, чтобы найти что-то новое для изучения, или продолжить со [[javascript:click('.next-page')][следующим уроком]].
#en: You can go back to the list of [[/list][modules]] to find what to learn next, or continue with the [[javascript:click('.next-page')][next lesson]].
